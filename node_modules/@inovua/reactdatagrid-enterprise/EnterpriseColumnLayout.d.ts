/**
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the Commercial License found in the
 * LICENSE file in the root directory of this source tree.
 */
import { MouseEvent, ReactNode } from 'react';
import InovuaDataGridColumnLayout from '@inovua/reactdatagrid-community/Layout/ColumnLayout';
import { TypeConstrainRegion, TypeConfig, RangeResultType, TypeComputedProps } from '@inovua/reactdatagrid-community/types';
type Event = MouseEvent & TouchEvent;
export default class InovuaDataGridEnterpriseColumnLayout extends InovuaDataGridColumnLayout {
    private dropIndex;
    private dragBoxInitialHeight;
    private dropRowHeight;
    private validDropPositions;
    private scrollTopRegionRef;
    private scrollBottomRegionRef;
    private dragRowArrow;
    private refDragRow;
    private refDragRowArrow;
    private dragRow;
    private content;
    private direction;
    private SCROLL_MARGIN;
    private DRAG_ROW_MAX_HEIGHT;
    private iterate;
    private DRAG_INFO;
    private scrolling;
    lastComputedProps?: TypeComputedProps;
    gridScrollInterval: any;
    constructor(props: any);
    renderLockedEndRows: (computedProps: TypeComputedProps) => any;
    renderLockedStartRows: (computedProps: TypeComputedProps) => any;
    renderLockedRows: (rows: any[], position: 'start' | 'end', computedProps: TypeComputedProps) => any;
    renderDragRowArrow: () => JSX.Element;
    renderReorderRowProxy: (props?: TypeComputedProps) => ReactNode;
    renderScrollingTopRegion: () => ReactNode;
    renderScrollingBottomRegion: () => ReactNode;
    onScrollingRegionMouseEnter: (event: any, dir?: -1 | 1) => void;
    startScrolling: (rowReorderScrollByAmount: number, dir: -1 | 1) => any;
    setScrollPosition: (scrollTop: number) => void;
    onScrollingRegionMouseLeave: () => void;
    getDragRowInstance: (dragIndex: number) => any;
    onDragRowMouseDownHandle: (ev: Event | any, index: number, cellNode: any) => void;
    setupDrag: (event: Event, { dragIndex, contentRegion, headerHeight, cellRegion, }: {
        dragIndex: number;
        contentRegion: TypeConstrainRegion;
        headerHeight: number;
        cellRegion: TypeConstrainRegion;
    }, props: any) => void;
    onRowDrag: (_event: Event, config: TypeConfig, props: any) => void;
    onRowDrop: (_event: Event, _config: TypeConfig, props: any) => void;
    updateDataSource: (props: any, { dropIndex, dragIndex }: {
        dropIndex: number;
        dragIndex: number;
    }) => void;
    updateTree: (props: any, dragIndex: number, dropIndex: number) => void;
    updateGroups: (props: TypeComputedProps, dragIndex: number, dropIndex: number) => Promise<void>;
    recomputeNodeProps: (data: any[], direction: number, dropIndex: number, dropDepth: number, destinationPath: string, pathSeparator: string) => any[];
    computedNesting: (props: any, dragProxyLeft: number, dragIndex: number, silentSetData: Function) => void;
    updateNesting: (dir: -1 | 1, props: any, dragIndex: number, silentSetData: Function) => void;
    computeItem: (props: any) => any;
    initDrag: ({ cellNode }: {
        cellNode: any;
    }) => {
        contentRegion: any;
        headerHeight: number;
        cellRegion: any;
    };
    getDropGroup: () => void;
    getDropParent: () => void;
    onRowReorder: (props: any, { dragIndex, dropIndex }: {
        dragIndex: number;
        dropIndex: number;
    }) => void;
    getDragProxy: (props: any, { dragIndex, contentRegion, cellRegion, dragBoxInitialRegion, }: {
        dragIndex: number;
        contentRegion: TypeConstrainRegion;
        cellRegion: TypeConstrainRegion;
        dragBoxInitialRegion: TypeConstrainRegion;
    }) => {
        dragProxy: any;
        dragProxyPosition: {
            top: number;
            left: number;
        };
        dragBoxOffsets: {
            top: number;
            left: number;
        };
        leftBoxOffset: number;
    };
    getDragBoxInitialRegion: ({ dragIndex }: {
        dragIndex: number;
    }) => {
        dragBoxInitialRegion: any;
        dragRowHeight: any;
    };
    setScrollRegionVisibility: (props: any) => void;
    getRanges: (props: any, { initialScrollTop, contentRegion, dragBoxInitialRegion, }: {
        initialScrollTop: number;
        contentRegion: TypeConstrainRegion;
        dragBoxInitialRegion: TypeConstrainRegion;
    }) => {
        ranges: RangeResultType[];
        selectedGroup: any;
        selectedParent: string;
    };
    compareRanges: ({ scrollDiff }: {
        scrollDiff: number;
    }) => any;
    adjustDragProxy: ({ diffTop, diffLeft, initialDiffTop, initialDiffLeft, dragProxyAdjust, }: {
        diffTop: number;
        diffLeft: number;
        initialDiffTop: number;
        initialDiffLeft: number;
        dragProxyAdjust: number;
    }) => {
        dragProxyTop: any;
        dragProxyLeft: any;
    };
    getValidDropPositions: (props: any, dragIndex: number, dropIndex: number) => any;
    clearDropInfo: () => void;
    cancelDrop: () => void;
    adjustScrollOnDrag: (props: any, config: TypeConfig) => {
        initialDiffTop: number;
        initialDiffLeft: number;
        dragProxyAdjust: number;
        scrollDiff: number;
        scrollTop: number;
        diffTop: number;
        diffLeft: number;
    };
    setReorderArrowAt: (index: number, ranges: RangeResultType[], direction: number, visible?: boolean) => void;
    setReorderArrowPosition: (top: number) => void;
    setReorderArrowVisible: (visible: boolean) => void;
    dragStartCallbacks: (props: TypeComputedProps, dragIndex: number, selectedGroup: string) => void;
    dragEndCallbacks: (props: TypeComputedProps, dropIndex: number | undefined) => void;
    dragEndGroupCallbacks: (props: TypeComputedProps, dropIndex: number | undefined, dropGroup: string) => void;
    onRowReorderValidation: (ev: Event | any, props: any, dragIndex: number) => boolean;
}
export {};
